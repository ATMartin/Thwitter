/**
 * First up, let's declare our Backbone structure elements.
 * Each of these makes up the core of our app. These are
 * CONSTRUCTORS, meaning we will use "new" on them in the
 * near future to create a new INSTANCE of them, which we
 * will reference with a variable name.
 *
 * Remember that using capital letters is a good practice
 * here, as it lets you & others know you're dealing with 
 * a constructor or class.
 **/

// Thweet is our functional unit - the message itself 
var Thweet = Backbone.Model.extend({});

// Thweets is our collection. We assign it a model of "Thweet",
// since it will holding multiple Thweet objects. 
var Thweets = Backbone.Collection.extend({
  model: Thweet
});

// ThweetInputView is our submission form. 
var ThweetInputView = Backbone.View.extend({
  
  // It creates a "form" object in the DOM
  tagName: 'form',
  
  // It uses a template named "submit-form" in our HTML.
  template: _.template($('[data-template-name="submit-form"]').text()),
  
  // It listens for the "submit" event, and calls the "submit" function
  // when it catches that event.
  events: {
    'submit' : 'submit' 
  },
  
  // The submit function adds a Thweet object to our collection. 
  // It gets the text from each text field and assigns it to a
  // 'message' and 'sender' variable on the object, and it assigns
  // a new ID calculated from the number of thweets already in the
  // collection plus one. 
  // This function also empties the text boxes after submitting.
  // It would be a good refactor to pull that out into a separate
  // function - handling both data and presentation in one function
  // can be BAD NEWS. I'll let it slide for now.
  submit: function(e) {
    e.preventDefault(); //<-- prevent page reload every time.
    this.collection.add({
      'id' : this.collection.length + 1,
      'message' : this.$('.msg').val(), 
      'sender'  : this.$('.sender').val()
    });
    // Empty our text boxes here.
    // NOTE: can't do this with "this.$('input')"
    // because of our submit button.
    this.$('.msg').val('');
    this.$('.sender').val('');
  },

  // Get the HTML generated by this view's template
  // and load it inside the view's element object ($el).
  render: function() {
    this.$el.html( this.template({}) );
    return this;
  }
});


// ThweetListView is a list of all the existing Thweets.
var ThweetListView = Backbone.View.extend({
  
  // It creates an unordered list in the DOM
  tagName: 'ul',

  // It uses a template named "thweet" from our HTML
  template: _.template($('[data-template-name="thweet"]').text()),
  
  // When it is first loaded, it starts listening to its collection object.
  // Whenever something is added to the collection, it will reload
  // the list to ensure it's up to date.
  initialize: function() {
    this.listenTo(this.collection, 'add', this.render);
  },

  // Empty the <UL> object, then reload each thweet
  // in the collection. 
  // - we assign "self" here because "this" changes inside
  //   the .each() function call, so "self" lets up keep
  //   access to our view's data.
  // - we .empty() the <UL> first because we're using .append().
  //   If we didn't empty, we would add the entire list back to
  //   itself on every render, which is really only funny the
  //   first time it happens to you.
  render: function() {
    var self = this;
    this.$el.empty();
    this.collection.each(function(thweet) {
      self.$el.append(self.template(thweet.attributes));
    });
  }
});

// These three lines are "seed data" - they create 3 simple
// thweets so we have something to look at in our collectio
// right off the bat. 
var thweet1 = new Thweet({id: 1, message: "Hello, world!", sender: "jacobthemyth"});
var thweet2 = new Thweet({id: 2, message: "Thup, guyth?", sender: "alekth"});
var thweet3 = new Thweet({id: 3, message: "Thith ith GREAT!", sender: "mathon"});

// Create an instance of our Thweets object, and load it 
// with our 3 "seed" Thweet objects from above. 
var thweets = new Thweets([thweet1, thweet2, thweet3]);

// Create instances of both our input form and our
// thweet list. We pass each of them our collection
// because they both need access:
//   - thweetView needs to be able to CREATE (.add) thweets to it
//   - thweetList needs to be able to READ (.listenTo) thweets from it
var thweetView = new ThweetInputView({collection: thweets});
var thweetList = new ThweetListView({collection: thweets});


// Here we set up our router. 
//  We have two routes:
//    (1) - "mysite.com/" - our index
//    (2) - "mysite.com#thweet/:id" - view a specific thweet with id <:id>
// index() just renders our input form and list of existing thweets
// We then add the form as our primary HTML and append the list of
// current thweets underneath it.
//
// thweet(id) loads just the tweet where (thweet.id === :id) <-- from URL
// and renders it with the thweet template.

var ThweetRouter = Backbone.Router.extend({
  routes: {
    '' : 'index',
    'thweet/:id' : 'thweet'  
  },
  index: function() {
    thweetView.render();
    thweetList.render();
    $('.thweet-app').html(thweetView.el)
    $('.thweet-app').append(thweetList.el);
  },
  thweet: function(id) {
    // .findWhere() searches a collection and returns the first item
    // that matches the parameters in the object you pass it.
    var requestedThweet = thweets.findWhere({id : +id});
    
    // If we found a thweet with that :id...
    if (requestedThweet) {
      $('.thweet-app').html(thweetList.template(requestedThweet.attributes));
    // ...but if we found no thweets that match...
    } else {
      $('.thweet-app').html('<h4>Thorry, no Thweets at that addreth!</h4>');
    }
  }
});

// Make a new instance of the Router
var appRouter = new ThweetRouter();
// Start Backbone's URL monitoring
Backbone.history.start();



